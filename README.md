# dreepo

Repository Pattern implementation for Firebase Realtime Database

[![TypeScript](https://badgen.net/badge/-/typescript?icon=typescript&label)](https://www.typescriptlang.org/)
[![tested with jest](https://img.shields.io/badge/tested_with-jest-99424f.svg)](https://github.com/facebook/jest)

## Overview

[Getting Started](#getting-started)  
[Installation](#installation)  
[Usage](#usage)  
[Built With](#built-with)  
[Contributing](docs/CONTRIBUTING.md)

## Getting Started

Inspired by [Fireorm][1], Dreepo exposes a Repository Pattern implementation for
[Firebase Realtime Database][2] instances.

Alongside an abstract database access layer, repositories also support:

- aggregation pipelines and queries using [mingo][3]
- [runtypes][4] model validation

## Installation

1. Create or edit an `.npmrc` file with the following information:

   ```utf-8
   @flex-development:registry=https://npm.pkg.github.com/
   ```

2. Add project to `dependencies`

   ```zsh
   yarn add @flex-development/dreepo # or npm i @flex-development/dreepo
   ```

## Usage

[Configuration](#configuration)  
[Creating a New Model](#creating-a-new-model)  
[Schema Validation](#schema-validation)  
[Creating a New Repository](#creating-a-new-repository)  
[Repository Cache](#repository-cache)  
[Repository Class API](#repository-class-api)

### Configuration

#### Firebase Service Account

Dreepo communicates with your Realtime Database using the [Firebase Database
REST API][2]. Generated by service accounts, [Google OAuth2 access tokens][5]
are used to authenticate requests.

1. Navigate to the [Service Accounts][6] section of the Firebase console

2. Click **Generate New Private Key** to generate a new service account key file

#### Environment Variables

- `DEBUG`: Toggle [debug][7] logs from the `dreepo` namespace
- `DEBUG_COLORS`: Toggle [debug][7] log namespace colors
- `FIREBASE_CLIENT_EMAIL`: Firebase Admin service account `client_email`
- `FIREBASE_DATABASE_URL`: Firebase Realtime Database URL
- `FIREBASE_PRIVATE_KEY`: Firebase Admin service account `private_key`

#### Mingo

The `Repository` class integrates with [mingo][3], a MongoDB query language for
in-memory objects, to support aggregation pipelines and querying.

Operators loaded by Dreepo can be viewed in the [config](src/config/mingo.ts)
file. If additional operators are needed, you'll need to load them on your own
_before_ instantiating a new repository.

#### TypeScript

For shorter import paths, TypeScript users can add the following aliases:

```json
{
  "compilerOptions": {
    "paths": {
      "@dreepo": ["node_modules/@flex-development/dreepo/index.js"],
      "@dreepo/*": ["node_modules/@flex-development/dreepo/*"]
    }
  }
}
```

These aliases will be used in following code examples.

### Creating a New Model

Before instantiating a new repository, a [runtypes][4] model needs to be
created.

For the next set of examples, the model `Car` will be used.

```typescript
import { Entity } from '@dreepo'
import type { QueryParams, RepoValidatorOptsDTO } from '@dreepo/lib/types'
import { Number, Static, String } from 'runtypes'

export const Car = Entity.extend({
  make: String,
  model: String,
  model_year: Number
})

export type CarEntity = Static<typeof Car>
export type CarQuery = QueryParams<CarEntity>
```

### Schema Validation

The repository model and schema validation options are consumed by the
`Repository` class as an options object:

```typescript
import type { RepoValidatorOptsDTO } from '@dreepo/lib/types'
import { ValidationError } from 'runtypes/lib/errors'
import type { Failure } from 'runtypes/lib/result'
import { Failcode } from 'runtypes/lib/result'

export const vopts: RepoValidatorOptsDTO<CarEntity> = {
  enabled: true,
  model: Car,
  refinement: async (value: CarEntity) => {
    if (!value.model.length) {
      const failure: Failure = {
        code: Failcode.CONTENT_INCORRECT,
        details: { model: value.model },
        message: 'Invalid model',
        success: false
      }

      throw new ValidationError(failure)
    }
  }
}
```

Note that `vopts.enabled` and `vopts.refinement` are optional.

By default, validation is enabled. If the `refinement` function is defined, it
is only passed `value` if initial validation passes.

### Creating a New Repository

```typescript
import { Repository } from '@dreepo'

export const REPO_PATH = 'cars'
export const CarRepo = new Repository<CarEntity, CarQuery>(REPO_PATH, vopts)

/**
 * Every repository uses the `FIREBASE_DATABASE_URL` environment variable to set
 * used the `DATABASE_URL` instance property. While implemented as `readonly`
 * property, it can be overridden.
 */

// @ts-expect-error overriding database URL
CarRepo.DATABASE_URL = 'https://other-database.firebaseio.com'
```

### Repository Cache

After instantiation, before calling any repository methods, the repository's
cache must be refreshed to keep the database and repository cache in sync.

If the cache is empty before running an aggregation pipeline or executing a
search, a warning will be logged to the console.

Not refreshing the cache before a write operation (`create`, `patch`, or `save`)
could lead to accidental overwrites or other database inconsistencies.

```typescript
await CarRepo.refreshCache()
```

### Repository Class API

The `Repository` class allows users to perform CRUD operations on their Realtime
Database, as well as check values against the repository model schema.

Documentation can be viewed [here](src/repositories/repository.ts).

```typescript
/**
 * `Repository` class interface.
 *
 * @template E - Entity
 * @template P - Query parameters
 */
export interface IRepository<
  E extends IEntity = IEntity,
  P extends QueryParams<E> = QueryParams<E>
> {
  readonly DATABASE_URL: string
  readonly cache: RepoCache<E>
  readonly http: RepoHttpClient
  readonly logger: Debugger
  readonly mingo: typeof mingo
  readonly mopts: MingoOptions
  readonly model: RuntypeBase<E>
  readonly path: string
  readonly vopts: RepoValidatorOpts<E>

  aggregate(
    pipeline?: OneOrMany<AggregationStages<E>>
  ): PartialOr<EntityEnhanced<E>>[] | RawArray
  clear(): Promise<boolean>
  create(dto: EntityDTO<E>): Promise<E>
  delete(id: OneOrMany<E['id']>, should_exist?: boolean): Promise<typeof id>
  find(params?: P): PartialOr<E>[]
  findByIds(ids: E['id'][], params?: P): PartialOr<E>[]
  findOne(id: E['id'], params?: P): PartialOr<E> | null
  findOneOrFail(id: E['id'], params?: P): PartialOr<E>
  patch(id: E['id'], dto: Partial<EntityDTO<E>>, rfields?: string[]): Promise<E>
  refreshCache(): Promise<RepoCache<E>>
  request<T = any>(config?: DBRequestConfig): Promise<T>
  save(dto: OneOrMany<PartialOr<EntityDTO<E>>>): Promise<E[]>
  validate<Value extends unknown = RawObject>(value?: Value): Promise<E | Value>
}
```

## Built With

- [Axios][8] - Promise based HTTP client
- [Firebase Database REST API][2] - REST API for Firebase Realtime Database
- [Google Auth Library Node.js Client][9] - Node.js library for Google OAuth2
- [debug][9] - JavaScript debugging utility
- [mingo][3] - MongoDB query language for in-memory objects
- [runtypes][4] - Runtime validation for static types

[1]: https://github.com/wovalle/fireorm
[2]: https://firebase.google.com/docs/reference/rest/database
[3]: https://github.com/kofrasa/mingo
[4]: https://github.com/pelotom/runtypes
[5]: https://developers.google.com/identity/protocols/oauth2
[6]:
  https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk
[7]: https://github.com/visionmedia/debug
[8]: https://github.com/axios/axios
[9]: https://github.com/googleapis/google-auth-library-nodejs
